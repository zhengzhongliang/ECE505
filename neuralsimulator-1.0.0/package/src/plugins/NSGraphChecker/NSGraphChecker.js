/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue Nov 29 2016 17:04:11 GMT-0700 (MST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/PluginMessage'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    PluginMessage) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of NSGraphChecker.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin NSGraphChecker.
     * @constructor
     */
    var NSGraphChecker = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.currentPath;
        this.childNode=[];
        this.childPath=[];
        this.allGraph;
        this.pluginMessage=[];
        this.numberOfGraph;
        this.indexOfSmallestGraph;
    };

    
    NSGraphChecker.metadata = pluginMetadata;


    NSGraphChecker.prototype = Object.create(PluginBase.prototype);
    NSGraphChecker.prototype.constructor = NSGraphChecker;

    NSGraphChecker.prototype.main = function (callback) {
        var self = this;
        return self.loadNodeMap(self.rootNode)
            .then(function(nodes){
                if(self.currentPath.length<1||self.currentPath.length>5){
                    self.pluginMessage[0]=new PluginMessage();
                    self.pluginMessage[0].severity='error';
                    self.pluginMessage[0].message='could not check this container.'
                    self.result.setSuccess(false);
                    callback(null,self.result);
                }
                else{
                    self.checkConnectedGraph(nodes);
                    self.pluginMessage[0]=new PluginMessage();
                    self.pluginMessage[0].severity='checked';
                    self.pluginMessage[0].message=self.numberOfGraph+' connected graphs in current container. The smallest graph has '+self.allGraph[self.indexOfSmallestGraph].length+' nodes. Node \''+self.core.getPath(self.allGraph[self.indexOfSmallestGraph][0])+'\' is a node in the smallest graph';
                    self.result.addMessage(self.pluginMessage[0]);
                    self.result.setSuccess(true);
                    callback(null,self.result);
                }
                //self.logger.info(self.allNode.length);
                
            })
            .catch(function (err) {
                callback(err, self.result);
            });
    };
    NSGraphChecker.prototype.loadNodeMap=function(node){    //load the nodes of drawing's children
        var self=this;
        return self.core.loadSubTree(node)
            .then(function(nodeArr){
                var nodes = {},
                    i;
                for (i = 0; i < nodeArr.length; i += 1) {
                    nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                    //if (self.isMetaTypeOf(nodeArr[i], self.META.Drawing)){    //modify here to include different windows
                    //    self.currentPath= self.core.getPath(nodeArr[i]);      //assign currentpath with self.activeNode
                    //}
                }
                self.currentPath=self.core.getPath(self.activeNode);
                var children=nodes[self.currentPath].children;
                var child,child_i;
                for (child_i in children){
                    child=children[child_i];
                    self.childNode.push(child);
                    self.childPath.push(self.core.getPath(child));
                }
                self.logger.info('push node succeed');
                return nodes;
            });
    }
    NSGraphChecker.prototype.checkConnectedGraph=function(nodes){
    //search strategy:
    //1, start from node[0]. if node[0] is an component, start from it. If it is a connection, find next node until find component
    //2, current node=node[this]
    //3, visited node=current node
    //4, find the children of current nodes
    //5, find the connections of children (src+dst)
    //6, find next nodes
    //7, compare next node with visited node. delete visited node from compare node.
    //8, next node=current node
    //9, add current nodes to visited node
    //useful commands: self.core.getChildrenPaths(nodes)
    //dst = self.core.getCollectionPaths(outnode, 'dst');  used for finding object's src or dst
    //src=self.core.getPointerPath(connection, 'src');   used for finding connection's src or dst
        
        
        var self=this;
        var currentNode=[];
        var nextNode=[];
        var visitedNode=[];
        var allCurrentNode=[];
        var graphCounter=0;

        var j;
        for (j=0;j<self.childNode.length;j+=1)
        {
            if(judgeIfConnection(self.childNode[j])==0){
                allCurrentNode.push(self.childNode[j]);
            }
        }
//self.logger.warn('all children node:',allCurrentNode.length);
        
        var unvisited=allCurrentNode;
        self.allGraph=new Array(100);
        
        //visitedNode.push(currentNode);
        self.numberOfGraph=0;
        while(unvisited.length>0)   //counts how many connected graphs
        {
            currentNode.push(unvisited[0]);
//self.logger.warn('start node:',self.core.getPath(unvisited[0]));
            var nodeInGraph=[];
            
            while(currentNode.length!=0)   //counts how many nodes in one connected graph
            {
                nodeInGraph=nodeInGraph.concat(currentNode); 
                //self.logger.warn(currentNode.length);
                //self.logger.warn(self.core.getPath(currentNode[0]));
                //self.logger.warn(self.core.getPath(nodeInGraph[0]));
                nodeInGraph=removeDuplicantNode(nodeInGraph);     //remove duplicant nodes in the list of nodes in current graph.
                //self.logger.warn('are we here?');
                
                visitedNode=visitedNode.concat(currentNode);     
                visitedNode=removeDuplicantNode(visitedNode);
                //self.logger.warn('concat work well');
                var j=0;
                for(j=0;j<currentNode.length;j+=1)     //count what are the nodes in next step of search.
                {                                      //search from current node, find what nodes are connected to current nodes. Connected nodes are stored in nextNode array. In the next iteration of search, we will start from nextNode.
                    if(judgeIfVoltageMeter(currentNode[j])){  
                        var src = self.core.getCollectionPaths(currentNode[j], 'src');
                        if(src!=''){
                            var dst=self.core.getPointerPath(nodes[src], 'dst');
                            nextNode.push(nodes[dst]);
                        }
                    }
                    //self.logger.warn('judge voltage goes well');
                    if(judgeIfComponent(currentNode[j])){
                        var dst=self.core.getCollectionPaths(currentNode[j], 'dst');
                        if(dst.length>0){
                            var src;
                            src=self.core.getPointerPath(nodes[dst], 'src'); 
                            nextNode.push(nodes[src]);
 
                        }
                        //self.logger.info(self.core.getPath(currentNode[j]));
                        var childrenPaths=[];
                        childrenPaths=childrenPaths.concat(self.core.getChildrenPaths(currentNode[j]));  
                        //self.logger.info(childrenPaths.length);
                        var l=0;
                        for (l=0;l<childrenPaths.length;l+=1)
                        {
                            //self.logger.info(childrenPaths[l]); good
                            if (self.isMetaTypeOf(nodes[childrenPaths[l]], self.META.OutPort)){
                                var src;
                                src = self.core.getCollectionPaths(nodes[childrenPaths[l]], 'src');
                                if(src.length>0){
                                    var dst;
                                    dst= self.core.getPointerPath(nodes[src], 'dst');
                                    var parent=self.core.getParent(nodes[dst]);
                                    nextNode.push(parent);
                                    //self.logger.info('out parent',self.core.getPath(parent));  good
                                }
                            }
                            //self.logger.info('judge neuron out');
                            if (self.isMetaTypeOf(nodes[childrenPaths[l]], self.META.InPort)){
                                var dst;
                                dst = self.core.getCollectionPaths(nodes[childrenPaths[l]], 'dst');
                                //self.logger.info('length:',dst.length); good
                                if(dst.length>0)
                                {
                                    var src;
                                    src=self.core.getPointerPath(nodes[dst], 'src');
                                    //self.logger.info('src:',src); good
                                    var parent=self.core.getParent(nodes[src]);
                                    nextNode.push(parent);
                                    //self.logger.info('in parent',self.core.getPath(parent));  good
                                }
                                //self.logger.info(self.core.getPath(nodes[src]));
                            }
                            if(judgeIfPart(nodes[childrenPaths[l]])==0){
                                //display error
                            }
                        }
                        
                        //nextNode=removeDuplicantNode(nextNode);      
                    } 
                    //self.logger.warn('judge neuron goes well');
                    if(judgeIfPart(currentNode[j])){
                        if (self.isMetaTypeOf(currentNode[j], self.META.OutPort)){  //question: it will go to another neuron.
                            var dst;
                            dst = self.core.getCollectionPaths(currentNode[j], 'dst');
                            if(dst.length>0){
                                var src;
                                src= self.core.getPointerPath(nodes[dst], 'src');
                                nextNode.push(nodes[src]);
//self.logger.info('Outport current node path:',self.core.getPath(currentNode[j]));
//self.logger.info('Outpot next node path:',src);
                            }
                        }
                        //self.logger.info('judge outport well');
                        if (self.isMetaTypeOf(currentNode[j], self.META.InPort)){
                            var src;
                            src = self.core.getCollectionPaths(currentNode[j], 'src');
                            if(src.length>0){
                                var dst;
                                dst=self.core.getPointerPath(nodes[src], 'dst');
                                nextNode.push(nodes[dst]);
//self.logger.info('Inport current node path:',self.core.getPath(currentNode[j]));
//self.logger.info('Inport next node path:',dst);
                            }
                        }
                        //self.logger.info('judge inport well');
                        //if (self.isMetaTypeOf(currentNode[j], self.META.NeuronChannel)){}
                        else{
                            var dst;
                            dst = self.core.getCollectionPaths(currentNode[j], 'dst');
                            if(dst.length>0){
                                var m=0;
                                for(m=0;m<dst.length;m+=1)
                                {
                                    var src;
                                    src= self.core.getPointerPath(nodes[dst[m]], 'src');
                                    if (self.core.getPath(self.core.getParent(nodes[src]))==self.currentPath){
                                        nextNode.push(nodes[src]);
                                    }
//self.logger.info('Inport current node path:',self.core.getPath(currentNode[j]));
//self.logger.info('Inport next node path:',src);
                                }
                            }
                            var src;
                            src = self.core.getCollectionPaths(currentNode[j], 'src');
                            if(src.length>0){
                                var m=0;
                                for(m=0;m<src.length;m+=1)
                                {
                                    var dst;
                                    dst= self.core.getPointerPath(nodes[src[m]], 'dst');
                                    if (self.core.getPath(self.core.getParent(nodes[dst]))==self.currentPath){
                                        nextNode.push(nodes[dst]);
                                    }
//self.logger.info('Inport current node path:',self.core.getPath(currentNode[j]));
//self.logger.info('Inport next node path:',dst);
                                }
                            }
                        }
                    }
                    //self.logger.warn('in neuron goes well');            
                }
                //self.logger.info('next node length',nextNode.length); good
                nextNode=removeDuplicantNode(nextNode);
                //if (nextNode.length>=2){self.logger.info(self.core.getPath(nextNode[0]));self.logger.info(self.core.getPath(nextNode[1]));}
                nextNode=nextNodeInGraph(nextNode,nodeInGraph);//need a function to compare nextNode and node in graph
                // if all nodes in this graph have been reached, then there is no need to continue searching in this graph anymore. So we will turn to next iteration of searching.
                //self.logger.info(self.core.getPath(nextNode[nextNode.length-1]));
                currentNode=[];
                currentNode=currentNode.concat(nextNode);  //when current node =ra and rp, it goes well
                //if (nodeInGraph.length>=2){self.logger.info(self.core.getPath(nodeInGraph[0]));self.logger.info(self.core.getPath(nodeInGraph[1]));}
                //currentNode=removeDuplicantNode(currentNode);
                nextNode=[];

            }
//self.logger.info('nodes in graph:',nodeInGraph.length);
            currentNode=[];
            visitedNode=visitedNode.concat(nodeInGraph);

            self.allGraph[graphCounter]=new Array();   //to be examined
            self.allGraph[graphCounter]=nodeInGraph;
            graphCounter=graphCounter+1;
            //allGraph.push(nodeInGraph);
            unvisited=unvisitedNode(visitedNode,allCurrentNode);
            self.numberOfGraph=self.numberOfGraph+1;
        }
//self.logger.info(self.allGraph[0].length);
        
        var idx=0;
        self.indexOfSmallestGraph=0;
        for (idx=1;idx<self.numberOfGraph;idx+=1){
            if (self.allGraph[self.indexOfSmallestGraph].length>self.allGraph[idx].length){
                self.indexOfSmallestGraph=idx;
            }
        }

        function judgeIfConnection(node){    //judge whether a node is a connection
            if(self.isMetaTypeOf(node, self.META.StableInAxon))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.UnstableInAxon))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.StableExAxon))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.UnstableExAxon))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.NeuronChannel))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.VoltageMeterLine))
            {return 1;}
            else {return 0;}
        }
        function judgeIfComponent(node){    //judge whether a node is neuron(or receptive field or executor )
            if(self.isMetaTypeOf(node, self.META.ReceptiveField))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.Executor))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.MultipolarNeuron))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.BipolarNeuron))
            {return 1;}
            else {return 0;}
        }
        function judgeIfPart(node){     //judge whether a node is a port or channel inside a neuron
            if(self.isMetaTypeOf(node, self.META.InPort))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.OutPort))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.MultipolarNeuronBody))
            {return 1;}
            if(self.isMetaTypeOf(node, self.META.BipolarNeuronBody))
            {return 1;}
            else {return 0;}
        }
        function judgeIfVoltageMeter(node){    //check whether the node is a voltage meter.
            if(self.isMetaTypeOf(node, self.META.VoltageMeter))
            {return 1;}
            else {return 0;}
        }
        function unvisitedNode(visited, all) { 
           var i=0;
           var unvisited=[];
           while(i<all.length){

               var j=0;
               var diffFlag=1;
               while((diffFlag==1)&&(j<visited.length)){
                   if(self.core.getPath(all[i])==self.core.getPath(visited[j])){
                       diffFlag=0; 
                   }
                   else{j=j+1;}
               }
               if(diffFlag==1){
                   unvisited=unvisited.concat(all[i]);
               }
               i=i+1;
           }
           return unvisited;         
        }
        function nextNodeInGraph(next,graph){
            var i=0;
            var startPosition=0;
            while(i<next.length){
               var j=0;
               var diff=0;
               while ((j<graph.length)&&(diff==0)){
                   if(self.core.getPath(next[i])==self.core.getPath(graph[j])){
                       next.splice(i,1);
                       diff=1;
                   }
                   else{j=j+1;}           
               }
               if(diff==0)
               {
                   i=i+1;
               }

            }
            return next;
        }
        function pathToIndex(path){
            var k=0;
            for (k=0;k<self.allPath.length;k+=1){
                if (path==self.allPath[k]){
                    return k;
                }
            }
        }
        function removeDuplicantNode(nodeArray){
            var times=nodeArray.length;
            //self.logger.warn('we should be here:', nodeArray.length);
            var i=0;
            var startPosition=0;
            //self.logger.warn('how many times',times-1);
            while(i<(nodeArray.length-1))
            {
                var j=0;
                var step=1;

                while(j<(nodeArray.length-startPosition-1))
                {
                    //self.logger.warn(self.core.getPath(nodeArray[1]));
                    //self.logger.warn(self.core.getPath(nodeArray[startPosition+step+step]));
                    if (self.core.getPath(nodeArray[startPosition])==self.core.getPath(nodeArray[startPosition+step])){
                     
                        nodeArray.splice(startPosition+step,1); 
                    }
                    else{step=step+1;}
                    j=j+1;
                }
                i=i+1;
                startPosition=startPosition+1;
            }
            return nodeArray;
        }

    };
    
    return NSGraphChecker;
});
