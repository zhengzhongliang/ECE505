/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Fri Dec 02 2016 01:10:17 GMT-0700 (MST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

/* this plugin is for developer. Some functions that are used in other plugins are tested in this plugin at first.
Do not run this plugin in webgme */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/PluginContext',
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of NSDeveloperPlugin.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin NSDeveloperPlugin.
     * @constructor
     */
    var NSDeveloperPlugin = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.currentPath;
        this.childNode=[];
        this.childPath=[];
        this.matrix={};
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    NSDeveloperPlugin.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    NSDeveloperPlugin.prototype = Object.create(PluginBase.prototype);
    NSDeveloperPlugin.prototype.constructor = NSDeveloperPlugin;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    NSDeveloperPlugin.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;
        return self.loadNodeMap(self.rootNode)
            .then(function(nodes){
                self.test(nodes);
                //self.logger.info(self.allNode.length);
                
            })
            .catch(function (err) {
                callback(err, self.result);
            });
    };
    NSDeveloperPlugin.prototype.loadNodeMap=function(node){    //load the nodes of drawing's children
        var self=this;
        return self.core.loadSubTree(node)
            .then(function(nodeArr){
                var nodes = {},
                    i;
                for (i = 0; i < nodeArr.length; i += 1) {
                    nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                    if (self.isMetaTypeOf(nodeArr[i], self.META.Drawing)){    //modify here to include different windows
                        self.currentPath= self.core.getPath(nodeArr[i]);      //assign currentpath with self.activeNode
                    }
                }
                var children=nodes[self.currentPath].children;
                var child,child_i;
                for (child_i in children){
                    child=children[child_i];
                    self.childNode.push(child);
                    self.childPath.push(self.core.getPath(child));
                }
                self.logger.info('push node succeed');
                return nodes;
            });
    }
    NSDeveloperPlugin.prototype.test=function(nodes){
        var fs = require('fs');
        var stream = fs.createWriteStream("HelloWorld.c");
        stream.once('open', function(fd) {
                


            stream.end();
        });       
    }

    return NSDeveloperPlugin;
});
//
        /*visitedNode=visitedNode.concat(self.childNode[0]).concat(self.childNode[1]);

        unvisited=unvisitedNode(visitedNode,self.childNode);
self.logger.info('unvisited:',unvisited.length);
        function unvisitedNode(visited, all) { 
           var i=0;
           var unvisited=[];
           while(i<all.length){

               var j=0;
               var diffFlag=1;
               while((diffFlag==1)&&(j<visited.length)){
                   if(self.core.getPath(all[i])==self.core.getPath(visited[j])){
                       diffFlag=0; 
                   }
                   else{j=j+1;}
               }
               if(diffFlag==1){
                   unvisited=unvisited.concat(all[i]);
               }
               i=i+1;
           }
           return unvisited;         
        }*/









        /*function nextNodeInGraph(next,graph){
            var i=0;
            var startPosition=0;
            while(i<next.length){
               var j=0;
               var diff=0;
               while ((j<graph.length)&&(diff==0)){
                   if(self.core.getPath(next[i])==self.core.getPath(graph[j])){
                       next.splice(i,1);
                       diff=1;
                   }
                   else{j=j+1;}           
               }
               if(diff==0)
               {
                   i=i+1;
               }

            }
            return next;
        }*/
        /*function removeDuplicantNode(nodeArray){
            var loopCounter=0;
            var times=nodeArray.length;
            //self.logger.warn('we should be here:', nodeArray.length);
            var i=0;
            var startPosition=0;
            //self.logger.warn('how many times',times-1);
            while(i<(nodeArray.length-1))
            {
self.logger.info('loop:',loopCounter);
                loopCounter=loopCounter+1;
                var j=0;
                var step=1;

                while(j<(nodeArray.length-startPosition-1))
                {
                    //self.logger.warn(self.core.getPath(nodeArray[1]));
                    //self.logger.warn(self.core.getPath(nodeArray[startPosition+step+step]));
                    if (self.core.getPath(nodeArray[startPosition])==self.core.getPath(nodeArray[startPosition+step])){
                     
                        nodeArray.splice(startPosition+step,1);
self.logger.info(nodeArray.length); 

                    }
                    else{step=step+1;}

                    j=j+1;
  
                }
self.logger.info('here?');
                i=i+1;
                startPosition=startPosition+1;
            }
            return nodeArray;
        }*/

