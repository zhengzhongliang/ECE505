/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 1.7.0 from webgme on Mon Nov 28 2016 19:17:31 GMT-0700 (MST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase',
    'plugin/PluginMessage'], function (
    PluginConfig,
    pluginMetadata,
    PluginBase,
    PluginMessage) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of NSCodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin NSCodeGenerator.
     * @constructor
     */
    var NSCodeGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
        this.drawingNode;
        this.drawingChild=[];
        this.components=[];
        this.rF=[];   //store receptive fields
        this.bP=[];   //store bipolar neuron
        this.mP=[];   //store multipolar neuron
        this.eX=[];   //store executor
        this.vM=[];   //store voltage meter
        this.allComponent=[];   //store all nodes
        this.matrix;  //store the connection matrix
        this.tRF=[];  //store the type of receptive field
        this.tBP=[];  //store the type of bipolar neuron
        this.tMP=[];  //...of multipolar neuron
        this.tEX=[];  //...of executor
        this.tVM=[];  //...of voltage meter
        this.tAll=[];  //store the type of all neurons
        this.stimulus;  //store stimulus data from receptive field
        this.subjectNeuron=[];  //store
        this.nodePosition;  //store the position of node
        this.pluginMessage=[];  //store message to be shown in browser
    };
    
    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    NSCodeGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    NSCodeGenerator.prototype = Object.create(PluginBase.prototype);
    NSCodeGenerator.prototype.constructor = NSCodeGenerator;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    
    NSCodeGenerator.prototype.main = function (callback) {

    var self = this,
        err;

    return self.loadNodeMap(self.rootNode)
	.then(function(nodes) {

            self.readIDAndType(nodes);       //read the types of neurons
            self.checkCellInvalid(nodes);        //prevent code generation if there are no neurons
            self.checkConnectionInvalid(nodes);  //prevent generation if one port has more than one connection
            return nodes;

	})
        .then(function(nodes){
            self.readMatrix(nodes);          //read the connection matrix of neurons         
            self.readStimulus(nodes);        //read the stimulus from receptive field
            self.readSubjectNeuron(nodes);   //read neurons that are being monitored by voltage meter
            self.readPosition(nodes);        //read the position of neurons
            return nodes;
        })
        .then(function(nodes){
            self.renameNode(nodes);          //give each neuron a unique name
            self.outputData();               //output code
            self.save();                     //save change
        })
        .then(function(nodes){               //output succeed, show the following information
            self.result.setSuccess(true);
            self.pluginMessage[0]=new PluginMessage();
            self.pluginMessage[0].message='Code Generated in Project Directory!';
            self.result.addMessage(self.pluginMessage[0]);
            callback(null,self.result);
        })
	.catch(function (err) {
	    self.logger.error('Yikes! Something bad happened',err);
            callback(err, self.result);
        });
    }


//------------------------------------------------------------------------------
    NSCodeGenerator.prototype.loadNodeMap=function(node){    //load the nodes of drawing's children
        var self=this;
        return self.core.loadSubTree(node)
            .then(function(nodeArr){
                var drawingPath;
                var nodes = {},
                    i;
                var drawingNumber=0;
                for (i = 0; i < nodeArr.length; i += 1) {
                    nodes[self.core.getPath(nodeArr[i])] = nodeArr[i];
                    if (self.isMetaTypeOf(nodeArr[i], self.META.Drawing)){    //modify here to include different windows
                        drawingPath= self.core.getPath(nodeArr[i]);      //assign currentpath with self.activeNode
                        drawingNumber=drawingNumber+1;
                    }
                }
                if (drawingNumber!=1){                         //prevent generation if there are more than one drawing
                    self.pluginMessage[0]=new PluginMessage();
                    self.pluginMessage[0].severity='error';
                    self.pluginMessage[0].message='Each Example Must Have Exactly One Drawing';
                    self.result.addMessage(self.pluginMessage[0]);
                    self.result.setSuccess(false);
                    throw new Error;
                }
                
                self.drawingNode=nodes[drawingPath];
                var children=nodes[drawingPath].children;
                var child,child_i;
                for (child_i in children){
                    child=children[child_i];
                    self.drawingChild.push(child);
                }
                return nodes;
            });
    }
//-------------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.readIDAndType=function(nodes){
        var self=this;
        var i;
        for (i=0;i<self.drawingChild.length;i+=1){
            if (self.isMetaTypeOf(self.drawingChild[i], self.META.ReceptiveField)){
                self.rF.push(self.drawingChild[i]);
                self.tRF.push('r');
            }
        }
        for (i=0;i<self.drawingChild.length;i+=1){
            if (self.isMetaTypeOf(self.drawingChild[i], self.META.BipolarNeuron)){
                self.bP.push(self.drawingChild[i]);
                self.tBP.push('b');
            }
        }
        for (i=0;i<self.drawingChild.length;i+=1){
            if (self.isMetaTypeOf(self.drawingChild[i], self.META.MultipolarNeuron)){
                self.mP.push(self.drawingChild[i]);
                self.tMP.push('m');
            }
        }
        for (i=0;i<self.drawingChild.length;i+=1){
            if (self.isMetaTypeOf(self.drawingChild[i], self.META.Executor)){
                self.eX.push(self.drawingChild[i]);
                self.tEX.push('e');
            }
        }
        for (i=0;i<self.drawingChild.length;i+=1){
            if (self.isMetaTypeOf(self.drawingChild[i], self.META.VoltageMeter)){
                self.vM.push(self.drawingChild[i]);
                self.tVM.push('v');
            }
        }
        self.allComponent=self.allComponent.concat(self.rF).concat(self.bP).concat(self.mP).concat(self.eX).concat(self.vM);
        self.tAll=self.tAll.concat(self.tRF).concat(self.tBP).concat(self.tMP).concat(self.tEX).concat(self.tVM);
      
    } //read good
//------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.readMatrix=function(nodes){
        var self=this;
        var row=3*(self.allComponent.length-self.vM.length-self.rF.length);
        var col=3*(self.rF.length+self.bP.length)+self.mP.length;

        var m;
        self.matrix=new Array(row);
        for (m=0;m<row;m+=1){
            self.matrix[m]=new Array(col);
        }
        var n;
        for(m=0;m<row;m+=1){
            for(n=0;n<col;n+=1){
                self.matrix[m][n]=0;
            }
        }

        var i;
        for (i=self.allComponent.length-self.vM.length-1;i>=self.rF.length;i-=1){   //
            var childrenPaths=[];
            childrenPaths=childrenPaths.concat(self.core.getChildrenPaths(self.allComponent[i]));
            var l=0;
            var index;
            var verticalPosition=(i-self.rF.length)*3;
            var horizontalBase=0;
            for (l=0;l<childrenPaths.length;l+=1){
                            
                if (self.isMetaTypeOf(nodes[childrenPaths[l]], self.META.InPort)){
                    var dst;
                    dst = self.core.getCollectionPaths(nodes[childrenPaths[l]], 'dst');
                    if(dst.length>0){
                        var value=0;
                        if(self.isMetaTypeOf(nodes[dst], self.META.StableExAxon)){
                            value=0.7;
                        }
                        if(self.isMetaTypeOf(nodes[dst], self.META.StableInAxon)){
                            value=-0.7;
                        }
                        if(self.isMetaTypeOf(nodes[dst], self.META.UnstableExAxon)){
                            value=0.3;
                        }
                        if(self.isMetaTypeOf(nodes[dst], self.META.UnstableInAxon)){
                            value=-0.7;
                        }

                        var src;
                        src= self.core.getPointerPath(nodes[dst], 'src');
                        var parent=self.core.getParent(nodes[src]);       
             
                        index=pathToIndex(self.core.getPath(parent));
                       //good
                        if (index<self.rF.length+self.bP.length){
                            horizontalBase=3*index;
                        }
                        else{
                            horizontalBase=index+2*(self.rF.length+self.bP.length);
                        }
                        var horizontalBias=0;
                        var flagAxonAdded=0;

                        while(flagAxonAdded==0){
                            var sum=0;
                            var s=0;
                            for (s=0;s<self.matrix.length;s+=1){
                                sum=sum+self.matrix[s][horizontalBase+horizontalBias];
                            }
                            if(sum==0){
                                self.matrix[verticalPosition][horizontalBase+horizontalBias]=value;
                                flagAxonAdded=1;
                                verticalPosition=verticalPosition+1
                            }
                            else{
                                horizontalBias=horizontalBias+1;
                            }
                        }                                 
                    }
                }
            }
        }
        function pathToIndex(path){
            var k=0;
            for (k=0;k<self.allComponent.length;k+=1){
                if(self.core.getPath(self.allComponent[k])==path){
                    return k;
                } 
            }
        }

        //self.logger.info(self.matrix);
    }
//------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.readPosition=function(nodes){
        var self=this;
        self.nodePosition=new Array(self.allComponent.length);
        var i=0;

        for (i=0;i<self.allComponent.length;i+=1){
            self.nodePosition[i]=new Array(2);
            var positionxy=self.core.getRegistry(self.allComponent[i],'position');    //position.x,   position.y
            self.nodePosition[i][0]=positionxy.x;
            self.nodePosition[i][1]=positionxy.y;
        }
        return nodes;
    }

//------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.renameNode=function(nodes){
        var self=this;
        var i=0;
        for (i=0;i<self.rF.length;i+=1){
            var newName;
            newName='Receptive Field '+(i+1).toString();
            var path=self.core.getPath(self.rF[i]);
            self.core.setAttribute(nodes[path],'name',newName);
        }
        for (i=0;i<self.bP.length;i+=1){
            var newName;
            newName='Bipolar Neuron '+(i+1).toString();
            var path=self.core.getPath(self.bP[i]);
            self.core.setAttribute(nodes[path],'name',newName);
        }
        for (i=0;i<self.mP.length;i+=1){
            var newName;
            newName='Multipolar Neuron '+(i+1).toString();
            var path=self.core.getPath(self.mP[i]);
            self.core.setAttribute(nodes[path],'name',newName);
        }
        for (i=0;i<self.eX.length;i+=1){
            var newName;
            newName='Executor '+(i+1).toString();
            var path=self.core.getPath(self.eX[i]);
            self.core.setAttribute(nodes[path],'name',newName);
        }
        for (i=0;i<self.vM.length;i+=1){
            var newName;
            newName='Voltage Meter '+(i+1).toString();
            var path=self.core.getPath(self.vM[i]);
            self.core.setAttribute(nodes[path],'name',newName);
        }
        
    }
   
//------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.readStimulus=function(nodes){
        var self=this;
        self.stimulus=new Array(self.rF.length);
        var i=0;
        for (i=0;i<self.rF.length;i+=1)
        {
            self.stimulus[i]=new Array(2);
            self.stimulus[i][0]=self.core.getAttribute(self.rF[i],'start_time');
            self.stimulus[i][1]=self.core.getAttribute(self.rF[i],'amplitude');
        }
    }
    NSCodeGenerator.prototype.readSubjectNeuron=function(nodes){
        var self=this;
        var i=0;
        for (i=0;i<self.vM.length;i+=1){
            var conPath=self.core.getCollectionPaths(self.vM[i],'src');
            var dst=self.core.getPointerPath(nodes[conPath],'dst');
            var neuronIndex=pathToIndex(dst);
            self.subjectNeuron=self.subjectNeuron.concat(neuronIndex);
        }
        function pathToIndex(path){
            var k=0;
            for (k=0;k<self.allComponent.length;k+=1){
                if(self.core.getPath(self.allComponent[k])==path){
                    return k;
                } 
            }
        }
    }
//-----------------------------------check model-------------------------------------
    NSCodeGenerator.prototype.checkCellInvalid=function(nodes){   //prevent generation if there are no neurons
        var self=this;
        var sum=0;
        sum=self.rF.length+self.bP.length+self.mP.length+self.eX.length;
        if (sum==0){
            self.pluginMessage[0]=new PluginMessage();
            self.pluginMessage[0].severity='error';
            self.pluginMessage[0].message='No nerve cells in current drawing!';
            self.result.addMessage(self.pluginMessage[0]);
            self.result.setSuccess(false);
            throw new Error;
        }
    }
    NSCodeGenerator.prototype.checkConnectionInvalid=function(nodes){
        var self=this;
        var invalid=0;
        var abnormalNode;
        var i=0;
        while(i<self.rF.length&&invalid==0){
            var paths=self.core.getChildrenPaths(self.rF[i]);
            var j=0;
            while(j<paths.length&&invalid==0){
                var src=self.core.getCollectionPaths(nodes[paths[j]],'src');
                if(src.length>1){
                   invalid=1;
                   abnormalNode=self.core.getPath(self.rF[i]);
                }
                else{
                   j=j+1;
                }
            }
            i=i+1;
        }

        var i=0;
        while(i<self.bP.length&&invalid==0){
            var paths=self.core.getChildrenPaths(self.bP[i]);
            var j=0;
            while(j<paths.length&&invalid==0){
                if(self.isMetaTypeOf(nodes[paths[j]], self.META.OutPort)){
                    var src=self.core.getCollectionPaths(nodes[paths[j]],'src');
                    if(src.length>1){
                       invalid=1;
                       abnormalNode=self.core.getPath(self.bP[i]);
                    }
                    else{
                       j=j+1;
                    }
                }
                if(self.isMetaTypeOf(nodes[paths[j]], self.META.InPort)){
                    var dst=self.core.getCollectionPaths(nodes[paths[j]],'dst');
                    if(dst.length>1){
                       invalid=1;
                       abnormalNode=self.core.getPath(self.bP[i]);
                    }
                    else{
                       j=j+1;
                    }
                }
                j=j+1;
            }
            i=i+1;
        }

        var i=0;
        while(i<self.mP.length&&invalid==0){
            var paths=self.core.getChildrenPaths(self.mP[i]);
            var j=0;
            while(j<paths.length&&invalid==0){
                if(self.isMetaTypeOf(nodes[paths[j]], self.META.OutPort)){
                    var src=self.core.getCollectionPaths(nodes[paths[j]],'src');
                    if(src.length>1){
                       invalid=1;
                       abnormalNode=self.core.getPath(self.mP[i]);
                    }
                    else{
                       j=j+1;
                    }
                }
                if(self.isMetaTypeOf(nodes[paths[j]], self.META.InPort)){
                    var dst=self.core.getCollectionPaths(nodes[paths[j]],'dst');
                    if(dst.length>1){
                       invalid=1;
                       abnormalNode=self.core.getPath(self.mP[i]);
                    }
                    else{
                       j=j+1;
                    }
                }
                j=j+1;
            }
            i=i+1;
        }

        var i=0;
        while(i<self.eX.length&&invalid==0){
            var paths=self.core.getChildrenPaths(self.eX[i]);
            var j=0;
            while(j<paths.length&&invalid==0){
                var dst=self.core.getCollectionPaths(nodes[paths[j]],'dst');
                if(src.length>1){
                   invalid=1;
                   abnormalNode=self.core.getPath(self.eX[i]);
                }
                else{
                   j=j+1;
                }
            }
            i=i+1;
        }

        var i=0;
        while(i<self.vM.length&&invalid==0){
            var src=self.core.getCollectionPaths(self.vM[i],'src');
            if(src.length>1){
                invalid=1;
                abnormalNode=self.core.getPath(self.vM[i]);
            }
            else{
                i=i+1;
            }
        }

        if (invalid==1){
            self.pluginMessage[0]=new PluginMessage();
            self.pluginMessage[0].severity='error';
            self.pluginMessage[0].message='Each port of neuron can only have 1 axon and each voltage meter can only monitor 1 cell! Node '+abnormalNode+' violates this rule!';
            self.result.addMessage(self.pluginMessage[0]);
            self.result.setSuccess(false);

            throw new Error;
        }
    }
    
//------------------------------------------------------------------------------------
    NSCodeGenerator.prototype.outputData=function(){

        var self=this;

        var fs = require('fs');    //write to file
        var stream = fs.createWriteStream("matlabcode2.c");

        stream.once('open', function(fd) {   //stuck here

            stream.write('hey');
self.logger.info('here?');
	    stream.end();

        });
    }
    return NSCodeGenerator;
});

            //--------output neuron type-----------------//
            /*var i=0;
            stream.write('type=[');
	    for (i=0;i<self.allComponent.length;i+=1)
            {
                stream.write('\''+self.tAll[i]+'\'');
                if(i!=self.allComponent.length-1){
                    stream.write(',');
                }
            }

            stream.write('];'+'\n');
            //----------------------------------------//
            //----------------output weight matrix----------------//
            var row=3*(self.allComponent.length-self.vM.length-self.rF.length);
            var col=3*(self.rF.length+self.bP.length)+self.mP.length;
            stream.write('W=[');
            var j=0;
            for (i=0;i<row;i+=1)
            {
                for (j=0;j<col;j+=1){
                    stream.write(self.matrix[i][j].toString());
                    if (j!=col-1){
                        stream.write(',');
                    }
                    else{
                        if(i==row-1){
                            stream.write('];'+'\n');
                        }
                        else{
                            stream.write(';'+'\n');
                        }
                    }
                }
            }
            //--------------------------------------------------
            //--------------Output stimulus---------------------
            stream.write('stimulus=[');

            for (i=0;i<self.stimulus.length;i+=1){
                stream.write(self.stimulus[i][0].toString()+','+self.stimulus[i][1].toString());
                if(i==self.stimulus.length-1){
                    stream.write('];'+'\n');
                }
                else{
                    stream.write(';');
                }
            }
            if(self.stimulus.length==0){
                stream.write('];'+'\n');
            }

            //--------------------------------------------------
            //-----------------Output subject neuron------------
            stream.write('subjectN=[');
            for (i=0;i<self.subjectNeuron.length;i+=1){
                stream.write(self.subjectNeuron[i].toString());
                if(i==self.subjectNeuron.length-1){
                    stream.write('];'+'\n');
                }
                else{
                    stream.write(',');
                }                
            }
            if(self.subjectNeuron.length==0){
                stream.write('];'+'\n');
            }
            //---------------------------------------------------
            //------------------Output neuron position----------
            stream.write('position=[');
            for (i=0;i<self.nodePosition.length;i+=1){
                stream.write(self.nodePosition[i][0].toString()+','+self.nodePosition[i][1].toString());
                if(i==self.nodePosition.length-1){
                    stream.write('];'+'\n');
                }
                else{
                    stream.write(';');
                }
            }*/

            //--------------------------------------------------
            //--------------------output simulation code------------------
                    /*stream.write('nr=sum(type==\'r\');'+'\n');
                    stream.write('nb=sum(type==\'b\');'+'\n');
                    stream.write('nm=sum(type==\'m\');'+'\n');
                    stream.write('ne=sum(type==\'e\');'+'\n');
                    stream.write('nv=sum(type==\'v\');'+'\n');
                    stream.write('nn=nr+nb+nm+ne;'+'\n'+'\n');

                    stream.write('I=zeros(nn,1); '+'\n');
                    stream.write('I_now=zeros(nn,1);'+'\n');
                    stream.write('I_last=zeros(nn,1);'+'\n');
                    stream.write('Ihistory=[];'+'\n');
                    stream.write('neuronVout=zeros(nr*3+nb*3+nm,1);'+'\n'+'\n');

                    stream.write('SNN.v=zeros(nn,1);'+'\n');
                    stream.write('SNN.u=zeros(nn,1);'+'\n');
                    stream.write('SNN.a=0.02*ones(nn,1);'+'\n');
                    stream.write('SNN.b=0.2*ones(nn,1);'+'\n');
                    stream.write('SNN.c=-65*ones(nn,1);'+'\n');
                    stream.write('SNN.d=8*ones(nn,1);'+'\n');
                    stream.write('SNN.v(nr+1:end)=-65;'+'\n');
                    stream.write('SNN.u=SNN.v.*SNN.b;'+'\n');
                    stream.write('SP_T = 30;'+'\n'+'\n');

                    stream.write('dt=0.5;'+'\n');
                    stream.write('tMax=1000;'+'\n');
                    stream.write('voltageHistory=[];'+'\n');
                    stream.write('xAxis=[0:dt:tMax];'+'\n'+'\n');

                    stream.write('for t=0:1:(tMax/dt)'+'\n');

                    stream.write('for (i=1:1:nr)'+'\n');
                    stream.write('if (t>stimulus(i,1)/dt&&t<(stimulus(i,1)+400)/dt)'+'\n');
                    stream.write('else'+'\n');
                    stream.write('end'+'\n');
                    stream.write('end'+'\n');
                    stream.write('for (i=1:1:nr+nb)'+'\n');
                    stream.write('neuronVout(3*i-2)=SNN.v(i);'+'\n');
                    stream.write('neuronVout(3*i-1)=SNN.v(i);'+'\n');
                    stream.write('neuronVout(3*i)=SNN.v(i);'+'\n');
                    stream.write('end'+'\n');
                    stream.write('for(i=nr+nb+1:nn-1)'+'\n');
                    stream.write('neuronVout(3*nr+3*nb+i-nr-nb)=SNN.v(i);'+'\n');
                    stream.write('end'+'\n');
                    stream.write('tempVout=neuronVout(3*nr+1:end,1);'+'\n');
                    stream.write('tempVout(tempVout<-55)=-65;'+'\n');
                    stream.write('tempVout=tempVout+65;'+'\n');
                    stream.write('neuronVout(3*nr+1:end,1)=tempVout;'+'\n');
                    stream.write('for (i=1:1:nn-nr)'+'\n');
                    stream.write('I_now(i+nr)=0.05*(W(3*i-2,:)+W(3*i-1,:)+W(3*i,:))*neuronVout(1:end,1);'+'\n');
                    stream.write('end'+'\n');
                    stream.write('I=I_now+I_last;'+'\n');
                    stream.write('I_last=I*0.9;'+'\n');
                    stream.write('I_last(1:nr)=0;'+'\n'+'\n');
        
 
                    stream.write('SNN.v(nr+1:end) = SNN.v(nr+1:end)+dt*(0.04*SNN.v(nr+1:end).^2+5*SNN.v(nr+1:end)+140-SNN.u(nr+1:end)+I(nr+1:end));'+'\n');
                    stream.write('SNN.u(nr+1:end) = SNN.u(nr+1:end)+SNN.a(nr+1:end).*(SNN.b(nr+1:end).*SNN.v(nr+1:end)-SNN.u(nr+1:end))*dt;'+'\n');
                    stream.write('s = (SNN.v >= SP_T);'+'\n');
                    stream.write('s = (SNN.v >= SP_T);'+'\n');
                    stream.write('s(1:nr)=0;'+'\n');
                    stream.write('SNN.v(s) = SNN.c(s);'+'\n');
                    stream.write('SNN.u(s) = SNN.u(s) + SNN.d(s);'+'\n');
                    stream.write('voltageHistory=[voltageHistory,SNN.v];'+'\n');

                    stream.write('if (size(subjectN,2)==1)'+'\n');
                    stream.write('xAxis=[0:dt:t*0.5];'+'\n');
                    stream.write('plot(xAxis,voltageHistory(subjectN(1),:));'+'\n');
                    stream.write('if (subjectN(1)>nr&&subjectN()<=(nn-ne))'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(1),\': Voltage Graph of Bipolar Neruon \',num2str(subjectN(1)-nr)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\');'+'\n');
                    stream.write('elseif (subjectN(1)>(nr+nb)&&subjectN(1)<=(nn-ne))'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(1),\': Voltage Graph of Multipolar Neruon \',num2str(subjectN(1)-nr-nb)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\')'+'\n');
                    stream.write('elseif (subjectN(1)<=nr)'+'\n');
                    stream.write('axis([0 tMax -10 70]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(1),\': Current Graph of Receptive Field \',num2str(subjectN(1))];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'current/uA\');'+'\n');
                    stream.write('else'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(1),\': Voltage Graph of Executor \',num2str(subjectN(1)-nr-nb-nm)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\');'+'\n');
                    stream.write('end'+'\n');
                    stream.write('end'+'\n');
                    stream.write('pause(0.002);'+'\n');
                    stream.write('end'+'\n'+'\n');

                    stream.write('if (size(subjectN,2)>1)'+'\n');
                    stream.write('for (i=1:1:size(subjectN,2))'+'\n');
                    stream.write('figure(i);'+'\n');
                    stream.write('xAxis=0:0.5:tMax;'+'\n');
                    stream.write('if (subjectN(i)>nr&&subjectN(i)<=(nr+nb))'+'\n');
                    stream.write('plot(xAxis,voltageHistory(subjectN(i),:));'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(i),\': Voltage Graph of Bipolar Neruon \',num2str(subjectN(i)-nr)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\');'+'\n');
                    stream.write('elseif (subjectN(i)>(nr+nb)&&subjectN(i)<=(nn-ne))'+'\n');
                    stream.write('plot(xAxis,voltageHistory(subjectN(i),:));'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(i),\': Voltage Graph of Mutipolar Neruon \',num2str(subjectN(i)-nr-nb)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\');'+'\n');
                    stream.write('elseif (subjectN(i)<=nr)'+'\n');
                    stream.write('plot(xAxis,voltageHistory(subjectN(i),:));'+'\n');
                    stream.write('axis([0 tMax -10 70]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(i),\': Current Graph of Receptive Field \',num2str(subjectN(i))];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'current/uA\');'+'\n');
                    stream.write('else'+'\n');
                    stream.write('plot(xAxis,voltageHistory(subjectN(i),:));'+'\n');
                    stream.write('axis([0 tMax -100 100]);'+'\n');
                    stream.write('graphTitle=[\'Graph \',num2str(i),\': Voltage Graph of Executor \',num2str(subjectN(i)-nr-nb-nm)];'+'\n');
                    stream.write('title(graphTitle);'+'\n');
                    stream.write('xlabel(\'time/ms\');'+'\n');
                    stream.write('ylabel(\'voltage/mV\');'+'\n');
                    stream.write('end'+'\n');
                    stream.write('end'+'\n');
                    stream.write('end'+'\n');*/
//-----------------------------------------------------------------------------------------------------------------


